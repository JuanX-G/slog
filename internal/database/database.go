package database

import (
	"context"
	"fmt"
	"os"
	"strconv"

	"github.com/jackc/pgx/v4/pgxpool"
)

func InitPool(dbPort string) *DB {
	dbPassword := os.Getenv("DBpassword")
	dbUrl := fmt.Sprintf("postgres://postgres:%s@localhost:" + dbPort + "/slog", dbPassword)
	ctx := context.Background()
	pool, err := pgxpool.Connect(ctx, dbUrl)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to connect to database: %v\n", err)
		os.Exit(1)
	}
	return  &DB{pool: pool}
}


/* db-object for the repo-pattern */
type DB struct {
	pool *pgxpool.Pool
}

func(d *DB) ConfigureDB() error {
	ctx := context.Background()
	var dbRes bool
	
	sqlQuery := "SELECT EXISTS (SELECT * FROM pg_tables WHERE tablename = 'users'); "
	err := d.pool.QueryRow(ctx, sqlQuery).Scan(&dbRes)
	if err != nil {
		return err
	}
	if dbRes == false {
		sqlQuery = "CREATE TABLE users (ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, user_name VARCHAR(64), email VARCHAR(255), date_created TIMESTAMP, password TEXT, description TEXT)"
		_, err = d.pool.Exec(context.Background(), sqlQuery)
		if err != nil {
			return err
		}
	}

	sqlQuery = "SELECT EXISTS (SELECT * FROM pg_tables WHERE tablename = 'posts'); "
	err = d.pool.QueryRow(ctx, sqlQuery).Scan(&dbRes)
	if err != nil {
		return err
	}
	if dbRes == false {
		sqlQuery = "CREATE TABLE posts (ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, author_id INT, content TEXT, date_created TIMESTAMP, title TEXT, tags TEXT, likes INT, FOREIGN KEY(author_id) REFERENCES users(ID))"
		_, err = d.pool.Exec(context.Background(), sqlQuery)
		if err != nil {
			return err
		}
	}
	sqlQuery = "SELECT EXISTS (SELECT * FROM pg_tables WHERE tablename = 'post_likes');"
	err = d.pool.QueryRow(ctx, sqlQuery).Scan(&dbRes)
	if err != nil {
		return err
	}
	if dbRes == false {
		sqlQuery = `CREATE TABLE post_likes (
			user_id INT NOT NULL,
			post_id INT NOT NULL,
			created_at TIMESTAMP DEFAULT NOW(),
			FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
			FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
			UNIQUE (user_id, post_id));`
		_, err = d.pool.Exec(context.Background(), sqlQuery)
		if err != nil {
			return err
		}
	}
	return nil
}

func (d *DB) InsertInto(ctx context.Context, tableName string, cols []string, values... any) error {
	if !isTableAllowed(tableName) {
		return fmt.Errorf("table %s not allowed", tableName)
	}
	if !areColumnsAllowed(tableName, cols) {
		return fmt.Errorf("columns %v not allowed for table %s", cols, tableName)
	}
	sqlQuery := fmt.Sprintf(`INSERT INTO %s (`, tableName)
	for i, v := range cols {
		if i != len(cols) - 1 { 
			sqlQuery = fmt.Sprint(sqlQuery, v, ", ") 
		} else {
			sqlQuery = fmt.Sprint(sqlQuery, v, ") VALUES (")
		}
	}
	
	for i := range values {
		if i != len(values) - 1 { 
			sqlQuery = fmt.Sprint(sqlQuery, "$", i + 1, ", ") 
		} else {
			sqlQuery = fmt.Sprint(sqlQuery, "$", i +1 , ");")
		}
	}
	_, err := d.pool.Exec(ctx, sqlQuery, values...)
	if err != nil {
		return err
	}	
	return nil 
}

type NotFoundError struct {
	queryParam string
}

func (e NotFoundError) Error() string {
	return e.queryParam
}

func(d *DB) QueryForRow(ctx context.Context, tableName string, col string, value string) ([]any, error) {
	if !isTableAllowed(tableName) {
		return nil, fmt.Errorf("table %s not allowed", tableName)
	}
	var cols = []string{col}
	if !areColumnsAllowed(tableName, cols) {
		return nil, fmt.Errorf("columns %v not allowed for table %s", cols, tableName)
	}
	sqlQuery := fmt.Sprintf(`SELECT * FROM %s WHERE %s= $1;`, tableName, col)
	rows, err := d.pool.Query(ctx, sqlQuery, value)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	if f := rows.Next(); !f {
		return nil, NotFoundError{queryParam: value}
	}
	vals, err := rows.Values()
	if err != nil {
		return nil, err
	}

	return vals, nil
}

func(d *DB) QueryCount(ctx context.Context, count int, tableName, col string, value any) ([][]any, error){
	if !isTableAllowed(tableName) {
		return nil, fmt.Errorf("table %s not allowed", tableName)
	}
	var cols = []string{col}
	if !areColumnsAllowed(tableName, cols) {
		return nil, fmt.Errorf("columns %v not allowed for table %s", cols, tableName)
	}
	sqlQuery := fmt.Sprintf(`SELECT * FROM %s WHERE %s= $1;`, tableName, col)
	rows, err := d.pool.Query(ctx, sqlQuery, value)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var rVals [][]any
	for (true) {
		if f := rows.Next(); !f {
			break;
		}
		aVals, err := rows.Values()
		if err != nil {
			return nil, err
		}
		rVals = append(rVals, aVals)
	}
	if len(rVals) == 0 {
		return nil, fmt.Errorf("No such rows")
	}
	if len(rVals) < count {
		return nil, fmt.Errorf("Count too big")
	}
	if count == -1 {
		return rVals, nil
	}
	return rVals[:count + 1], nil
}

func (db *DB) QueryCountOffset(ctx context.Context, count int, offset int, table string, column string, value any) ([][]any, error) { 
	if !isTableAllowed(table) { 
		return nil, fmt.Errorf("table %s not allowed", table) 
	} 
	var cols = []string{column} 
	if !areColumnsAllowed(table, cols) { 
		return nil, fmt.Errorf("columns %v not allowed for table %s", cols, table) 
	} 
	query := fmt.Sprintf("SELECT * FROM %s WHERE %s = $1 ORDER BY date_created DESC LIMIT $2 OFFSET $3", table, column) 
	rows, err := db.pool.Query(ctx, query, value, count, offset)
	if err != nil { 
		return nil, err 
	} 
	defer rows.Close() 
	var result [][]any 
	for rows.Next() { 
		vals, err := rows.Values() 
		if err != nil { 
			return nil, err 
		} 
		result = append(result, vals) 
	} 
	if len(result) == 0 { 
		return nil, fmt.Errorf("no results found") 
	} 
	if count == -1 { 
		return result, nil 
	} 
	return result[:count], nil 
}

func (d *DB) DeleteWhere(ctx context.Context, tableName string, cols []string, values... any) error {
	if !isTableAllowed(tableName) {
		return fmt.Errorf("table %s not allowed", tableName)
	}
	if !areColumnsAllowed(tableName, cols) {
		return fmt.Errorf("columns %v not allowed for table %s", cols, tableName)
	}
	sqlQuery := fmt.Sprintf(`DELETE FROM %s `, tableName)
	sqlQuery = fmt.Sprint(sqlQuery, "WHERE ")
	for i, v := range cols {
		if i != len(cols) - 1 { 
			sqlQuery = fmt.Sprint(sqlQuery, v, " = $", strconv.Itoa(i + 1), " AND ") 
		} else {
			sqlQuery = fmt.Sprint(sqlQuery, v, " = $", strconv.Itoa(i + 1)) 
		}
	}
	_, err := d.pool.Exec(ctx, sqlQuery, values...)
	if err != nil {
		return err
	}	
	return nil 
}

func (d *DB) CountWhere(ctx context.Context, tableName string, cols []string, values... any) (int32, error) {
	if !isTableAllowed(tableName) {
		return 0, fmt.Errorf("table %s not allowed", tableName)
	}
	if !areColumnsAllowed(tableName, cols) {
		return 0, fmt.Errorf("columns %v not allowed for table %s", cols, tableName)
	}
	sqlQuery := fmt.Sprintf(`SELECT COUNT(*) FROM %s `, tableName)
	sqlQuery = fmt.Sprint(sqlQuery, "WHERE ")
	for i, v := range cols {
		if i != len(cols) - 1 { 
			sqlQuery = fmt.Sprint(sqlQuery, v, " = $", strconv.Itoa(i + 1), " AND ") 
		} else {
			sqlQuery = fmt.Sprint(sqlQuery, v, " = $", strconv.Itoa(i + 1)) 
		}
	}
	var count int32
	err := d.pool.QueryRow(ctx, sqlQuery, values...).Scan(&count)
	if err != nil {
		return 0, err
	}
	return count, nil 
}
