package database

import (
	"context"
	"fmt"
	"os"

	"github.com/jackc/pgx/v4/pgxpool"
)

func InitPool() *DB {
	dbPassword := os.Getenv("DBpassword")
	dbUrl := fmt.Sprintf("postgres://postgres:%s@localhost:5432/slog", dbPassword)
	ctx := context.Background()
	pool, err := pgxpool.Connect(ctx, dbUrl)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to connect to database: %v\n", err)
		os.Exit(1)
	}
	return  &DB{pool: pool}
}


/* db-object for the repo-pattern */
type DB struct {
	pool *pgxpool.Pool
}

func(d *DB) ConfigureDB() error {
	ctx := context.Background()
	var dbRes bool
	
	sqlQuery := "SELECT EXISTS (SELECT * FROM pg_tables WHERE tablename = 'users'); "
	err := d.pool.QueryRow(ctx, sqlQuery).Scan(&dbRes)
	if err != nil {
		return err
	}
	if dbRes == false {
		sqlQuery = "CREATE TABLE users (ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, user_name VARCHAR(64), email VARCHAR(255), date_created TIMESTAMP, password TEXT)"
		_, err = d.pool.Exec(context.Background(), sqlQuery)
		if err != nil {
			return err
		}
	}

	sqlQuery = "SELECT EXISTS (SELECT * FROM pg_tables WHERE tablename = 'posts'); "
	err = d.pool.QueryRow(ctx, sqlQuery).Scan(&dbRes)
	if err != nil {
		return err
	}
	if dbRes == false {
		sqlQuery = "CREATE TABLE posts (ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, author_id INT, content TEXT, date_created TIMESTAMP, tags TEXT, FOREIGN KEY(author_id) REFERENCES users(ID), title TEXT)"
		_, err = d.pool.Exec(context.Background(), sqlQuery)
		if err != nil {
			return err
		}
	}
	return nil
}

func (d *DB) InsertInto(ctx context.Context, tableName string, cols []string, values... any) error {
	if !isTableAllowed(tableName) {
		return fmt.Errorf("table %s not allowed", tableName)
	}
	if !areColumnsAllowed(tableName, cols) {
		return fmt.Errorf("columns %v not allowed for table %s", cols, tableName)
	}
	sqlQuery := fmt.Sprintf(`INSERT INTO %s (`, tableName)
	for i, v := range cols {
		if i != len(cols) - 1 { 
			sqlQuery = fmt.Sprint(sqlQuery, v, ", ") 
		} else {
			sqlQuery = fmt.Sprint(sqlQuery, v, ") VALUES (")
		}
	}
	
	for i := range values {
		if i != len(values) - 1 { 
			sqlQuery = fmt.Sprint(sqlQuery, "$", i + 1, ", ") 
		} else {
			sqlQuery = fmt.Sprint(sqlQuery, "$", i +1 , ");")
		}
	}
	_, err := d.pool.Exec(ctx, sqlQuery, values...)
	if err != nil {
		return err
	}	
	return nil 
}

type NotFoundError struct {
	queryParam string
}

func (e NotFoundError) Error() string {
	return e.queryParam
}

func(d *DB) QueryForRow(ctx context.Context, tableName string, col string, value string) ([]any, error) {
	if !isTableAllowed(tableName) {
		return nil, fmt.Errorf("table %s not allowed", tableName)
	}
	var cols = []string{col}
	if !areColumnsAllowed(tableName, cols) {
		return nil, fmt.Errorf("columns %v not allowed for table %s", cols, tableName)
	}
	sqlQuery := fmt.Sprintf(`SELECT * FROM %s WHERE %s= $1;`, tableName, col)
	rows, err := d.pool.Query(ctx, sqlQuery, value)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	if f := rows.Next(); !f {
		return nil, NotFoundError{queryParam: value}
	}
	vals, err := rows.Values()
	if err != nil {
		return nil, err
	}

	return vals, nil
}

func(d *DB) QueryCount(ctx context.Context, count int, tableName, col string, value any) ([][]any, error){
	if !isTableAllowed(tableName) {
		return nil, fmt.Errorf("table %s not allowed", tableName)
	}
	var cols = []string{col}
	if !areColumnsAllowed(tableName, cols) {
		return nil, fmt.Errorf("columns %v not allowed for table %s", cols, tableName)
	}
	sqlQuery := fmt.Sprintf(`SELECT * FROM %s WHERE %s= $1;`, tableName, col)
	rows, err := d.pool.Query(ctx, sqlQuery, value)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var rVals [][]any
	for (true) {
		if f := rows.Next(); !f {
			break;
		}
		aVals, err := rows.Values()
		if err != nil {
			return nil, err
		}
		rVals = append(rVals, aVals)
	}
	if len(rVals) == 0 {
		return nil, fmt.Errorf("No such rows")
	}
	if len(rVals) < count {
		return nil, fmt.Errorf("Count too big")
	}
	if count == -1 {
		return rVals, nil
	}
	return rVals[:count + 1], nil
}

func (db *DB) QueryCountOffset(ctx context.Context, count int, offset int, table string, column string, value any) ([][]any, error) { 
	if !isTableAllowed(table) { 
		return nil, fmt.Errorf("table %s not allowed", table) 
	} 
	var cols = []string{column} 
	if !areColumnsAllowed(table, cols) { 
		return nil, fmt.Errorf("columns %v not allowed for table %s", cols, table) 
	} 
	query := fmt.Sprintf("SELECT * FROM %s WHERE %s = $1 ORDER BY date_created DESC LIMIT $2 OFFSET $3", table, column) 
	rows, err := db.pool.Query(ctx, query, value, count, offset)
	if err != nil { 
		return nil, err 
	} 
	defer rows.Close() 
	var result [][]any 
	for rows.Next() { 
		vals, err := rows.Values() 
		if err != nil { 
			return nil, err } 
			result = append(result, vals) 
		} 
		if len(result) == 0 { 
			return nil, fmt.Errorf("no results found") 
		} 
		if count == -1 { 
			return result, nil 
		} 
		return result[:count], nil 
	}
