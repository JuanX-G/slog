package passwordutils

import (
"errors"

"golang.org/x/crypto/bcrypt"
)

func HashPassword(pass string) (string, error) {
if len(pass) > 72 {
return "", errors.New("Passowrd to long, max length is 71")
} 
b, err := bcrypt.GenerateFromPassword([]byte(pass), 12)
if err != nil {
return "", err
}
return string(b), nil
}

func CheckPassword(hash, pass string) error { 
return bcrypt.CompareHashAndPassword([]byte(hash), []byte(pass))
}
package auth

import (
"crypto/rand"
"encoding/hex"
"fmt"
"net/http"
"sync"
"time"
)

const TOKEN_TTL = time.Hour
type AuthManager struct {
sessionStore map[string]Session
storeLock    sync.RWMutex
}

func NewAuthManager() *AuthManager {
return &AuthManager{
sessionStore: make(map[string]Session),
}


}

type Session struct {
UserID    string
ExpiresAt time.Time
}


func GenerateToken() (string, error) {
bytes := make([]byte, 32) // 256 bits
if _, err := rand.Read(bytes); err != nil {
return "", err
}
return hex.EncodeToString(bytes), nil
}

func(a *AuthManager) LogoutHandler(w http.ResponseWriter, r *http.Request) {
token := r.Header.Get("X-Auth-Token")
a.storeLock.Lock()
delete(a.sessionStore, token)
a.storeLock.Unlock()
fmt.Fprintln(w, "Logged out")
}

func(a *AuthManager) Login(token, userID string) {
a.storeLock.Lock()
a.sessionStore[token] = Session{
UserID:    userID,
ExpiresAt: time.Now().Add(TOKEN_TTL),
}
a.storeLock.Unlock()
}

func(a *AuthManager) LookupToken(token string) (session Session, ok bool) {
a.storeLock.RLock()
session, ok = a.sessionStore[token]
a.storeLock.RUnlock()
return
}
package database

import (
"context"
"fmt"
"os"

"github.com/jackc/pgx/v4/pgxpool"
)

func InitPool() *DB {
dbPassword := os.Getenv("DBpassword")
dbUrl := fmt.Sprintf("postgres://postgres:%s@localhost:5432/slog", dbPassword)
ctx := context.Background()
pool, err := pgxpool.Connect(ctx, dbUrl)
if err != nil {
fmt.Fprintf(os.Stderr, "Unable to connect to database: %v\n", err)
os.Exit(1)
}
return  &DB{pool: pool}
}

/* db-object for the repo-pattern */
type DB struct {
pool *pgxpool.Pool
}

func(d *DB) ConfigureDB() error {
ctx := context.Background()
var dbRes bool

sqlQuery := "SELECT EXISTS (SELECT * FROM pg_tables WHERE tablename = 'users'); "
err := d.pool.QueryRow(ctx, sqlQuery).Scan(&dbRes)
if err != nil {
return err
}
if dbRes == false {
sqlQuery = "CREATE TABLE users (ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, user_name VARCHAR(64), email VARCHAR(255), date_created TIMESTAMP, password TEXT)"
_, err = d.pool.Exec(context.Background(), sqlQuery)
if err != nil {
return err
}
}

sqlQuery = "SELECT EXISTS (SELECT * FROM pg_tables WHERE tablename = 'posts'); "
err = d.pool.QueryRow(ctx, sqlQuery).Scan(&dbRes)
if err != nil {
return err
}
if dbRes == false {
sqlQuery = "CREATE TABLE posts (ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, author_id INT, content TEXT, date_created TIMESTAMP, tags TEXT, FOREIGN KEY(author_id) REFERENCES users(ID))"
_, err = d.pool.Exec(context.Background(), sqlQuery)
if err != nil {
return err
}
}
return nil
}

func (d *DB) InsertInto(ctx context.Context, tableName string, cols []string, values... any) error {
sqlQuery := fmt.Sprintf(`INSERT INTO %s (`, tableName)
for i, v := range cols {
if i != len(cols) - 1 { 
sqlQuery = fmt.Sprint(sqlQuery, v, ", ") 
} else {
sqlQuery = fmt.Sprint(sqlQuery, v, ") VALUES (")
}
}

for i := range values {
if i != len(values) - 1 { 
sqlQuery = fmt.Sprint(sqlQuery, "$", i + 1, ", ") 
} else {
sqlQuery = fmt.Sprint(sqlQuery, "$", i +1 , ");")
}
}
_, err := d.pool.Exec(ctx, sqlQuery, values...)
if err != nil {
return err
}
return nil 
}

type NotFoundError struct {
queryParam string
}

func (e NotFoundError) Error() string {
return e.queryParam
}

func(d *DB) QueryForRow(ctx context.Context, tableName string, col string, value string) ([]any, error) {
sqlQuery := fmt.Sprintf(`SELECT * FROM %s WHERE %s= $1;`, tableName, col)
rows, err := d.pool.Query(ctx, sqlQuery, value)
if err != nil {
return nil, err
}
defer rows.Close()
if f := rows.Next(); !f {
return nil, NotFoundError{queryParam: value}
}
vals, err := rows.Values()
if err != nil {
return nil, err
}

return vals, nil
}

func(d *DB) QueryCount(ctx context.Context, count int, tableName, col string, value any) ([][]any, error){
sqlQuery := fmt.Sprintf(`SELECT * FROM %s WHERE %s= $1;`, tableName, col)
rows, err := d.pool.Query(ctx, sqlQuery, value)
if err != nil {
return nil, err
}
defer rows.Close()
var rVals [][]any
for (true) {
if f := rows.Next(); !f {
break;
}
aVals, err := rows.Values()
if err != nil {
return nil, err
}
rVals = append(rVals, aVals)
}
if len(rVals) == 0 {
return nil, fmt.Errorf("No such rows")
}
if len(rVals) < count + 2 {
return nil, fmt.Errorf("Count too big")
}
if count == -1 {
return rVals, nil
}
return rVals[:count + 1], nil
}

func (db *DB) QueryCountOffset(ctx context.Context, count int, offset int, table string, column string, value any) ([][]any, error) {
query := fmt.Sprintf(`SELECT * FROM %s WHERE %s = $1 ORDER BY date_created DESC LIMIT $2 OFFSET $3`, table, column)
rows, err := db.pool.Query(ctx, query, value, count, offset)
if err != nil {
return nil, err
}
defer rows.Close()

var result [][]any
for rows.Next() {
vals, err := rows.Values()
if err != nil {
return nil, err
}
result = append(result, vals)
}
if len(result) == 0 {
return nil, fmt.Errorf("no results found")
}

if count == -1 {
return result, nil
}

if len(result) < count {
return result, nil 
}

return result[:count], nil

}

package httpLogger

import (
"strconv"
"strings"
"time"
)
type HttpLogData struct {
Method string 
URL string
Referer string
UserAgent string
IP string
Code int
Duration time.Duration
}

func (h HttpLogData) String() string {
b := strings.Builder{}
b.WriteString("HTTP request log\nURL: ")
b.WriteString(h.URL + "\nMethod: ")
b.WriteString(h.Method + "\nRemote address: ")
b.WriteString(h.IP + "\nUser agent: ")
b.WriteString(h.UserAgent + "\nReferer: ")
b.WriteString(h.Referer + "\nCode: ")
b.WriteString(strconv.Itoa(h.Code) + "\nDuration: ")
b.WriteString(h.Duration.String() + "\n")

return b.String()
}

package httplogging

import (
"log"
"time"
)

type logEntry struct {
timestamp time.Time 
msg string
}

type Logger struct {
logChan chan logEntry
}

func (l *Logger) LogString(msg string) {
    l.logChan <- logEntry{msg: msg, timestamp: time.Now()} 
}

func (l *Logger) LogStruct(arg Logable) {
    l.logChan <- logEntry{msg: arg.String(), timestamp: time.Now()} 
}

func(l Logger) LogsWatchdog() {
for v := range l.logChan {
log.Print(v.msg)
}
}

func NewLogger() *Logger {
return &Logger{
logChan: make(chan logEntry
